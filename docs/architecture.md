## Цели
- Писать на TypeScript с strict: true
- Следовать принципам SOLID
- Архитектура: feature-sliced (или layer-based) + чистые зависимости
- 100% ESLint clean, форматирование Prettier
- Не допускать файлы больше 700–800 строк, при необходимости обоснованно выносить в отдельные компоненты/модули
- Код читабельный и единообразный: именование, структура файлов, порядок экспортов

SOLID - как основа при проектировании интерфейсов (не жесткое требование в тонкостях)
- S (SRP): каждый модуль делает одно дело, ничего не смешивать
- O (OCP): расширяем через новые реализации/композицию, а не через правки существующих модулей
- L (LSP): не ломаем контракт при наследовании/реализациях интерфейсов
- I (ISP): мелкие интерфейсы без "божественных" типов
- D (DIP): зависимости через абстракции (интерфейсы/фасады), внедрение - в композиционном корне
- Нарушаем SOLID осознанно, если это упрощает код и не ломает архитектурные границы слоёв

## Границы слоёв
- app/ - композиция, DI-контейнер, маршрутизация, wiring слоёв
- entities/ - базовые доменные модели и логика вокруг них
- features/ - законченные пользовательские возможности на базе entities
- widgets/ - сложные композиции UI из features/entities
- shared/ - утилиты, дизайн-система, базовые типы без бизнес или сложной функциональной (визуальной) логики

Правило зависимостей (не увлекаться по первым двум пунктам, если что - я поправлю, главное, в голове держать основы fsd)
- Запрещено импортировать "вверх" (из более низкого слоя в более высокий)
- Запрещено пересекать срезы feature-sliced напрямую, обходя публичные API (использовать публичные entry-пойнты слоёв)
- Переиспользование через публичные модули (`index.ts`), без "глубоких" относительных импортов в чужие внутренности
- На старте фичи допускается более «толстый» срез (например, часть логики прямо в feature/widget); по мере роста - декомпозировать в entities/shared

## Next.js (App Router) — правила
Проект на Next.js (App Router), поэтому важно держать границу Server/Client и не «смешивать» ответственность.

- **Server Components по умолчанию**: файлы в `src/app/**` без `"use client"` считаются server.
- **Client Components**: только там, где реально нужны хуки/DOM/анимации. Добавляем `"use client"` максимально локально.
- **Импорты**:
  - Server → может импортировать Client (но тогда место импорта станет клиентским boundary). Делай это осознанно и максимально низко в дереве.
  - Client → НЕ импортирует server-only код (fs, next/headers, server actions, прямой доступ к секретным env и т.д.).
- **Data fetching**:
  - Запросы для страниц/виджетов по умолчанию делаем на сервере (Server Components) и передаём данные вниз.
  - Кэш/инвалидацию фиксируем через `fetch(..., { next: { revalidate } })` или `cache`/`no-store` по необходимости.
  - Любая «форматирующая/валидационная» логика — в чистых функциях (shared/lib), не в компонентах.
- **Middleware**:
  - Используем для edge-задач (rewrite/redirect/headers), не для «бизнес-логики».
  - Секреты/токены — только из server-only env, никаких хардкодов.

## Public API модулей (обязательное правило)
Любой импорт **внутри проекта** должен идти через публичный API модуля (barrel file), без «ныряния» во внутренности.

- В каждом срезе делаем entry-point: `entities/<slice>/index.ts`, `features/<slice>/index.ts`, `shared/<segment>/index.ts`, и т.п.
- Разрешены импорты:
  - `import { getFaqs } from 'entities/faq'`
  - `import { HeaderContextProvider } from 'shared/contexts'`
- Запрещены импорты:
  - `shared/contexts/contexts/HeaderContext`
  - `entities/faq/api` (если `api` не является публичной частью контракта)

Если очень нужно открыть внутренний модуль наружу — **экспортируем его явно** из `index.ts`, а не импортируем глубоко.

## Алиасы и единообразие импортов
Сейчас в проекте есть и `@/*`, и алиасы слоёв (`shared/*`, `entities/*`, ...). Чтобы код был единообразным:

- **FSD-слои** импортируем только через алиасы слоёв: `app/*`, `shared/*`, `entities/*`, `features/*`, `widgets/*`.
- **Технические корневые каталоги** (например `types`, `assets`) импортируем через `@/types/*`, `@/assets/*`.
- **Не смешиваем** `@/shared/...` и `shared/...` в одном проекте: выбираем один стиль (рекомендуется `shared/*` для FSD).

## Legacy / зона миграции (временное правило)
Если в проекте есть «исторические» каталоги (например `src/components`, `src/hook`, `src/config`), фиксируем это прямо:

- **Новый код** не добавляем в legacy-папки (кроме очень обоснованных случаев).
- При правках legacy-кода — стараемся вынести переиспользуемое в `shared/*`, а предметную логику — в `entities/features/widgets`.
- Любые новые публичные компоненты/хуки — только в `shared/ui`, `shared/hooks`.

## Env / конфигурация
Чтобы не плодить магию и не тянуть `process.env` по всему коду:

- **Именование**:
  - публичные (для клиента) — только `NEXT_PUBLIC_*`
  - серверные секреты — только `UPPER_SNAKE_CASE` без `NEXT_PUBLIC_`
- **Чтение env**:
  - читаем env централизованно в одном месте (например `shared/config/env.ts`) и экспортируем типизированные значения
  - в компонентах — используем уже готовые значения/функции
- **Валидация** (желательно): проверяем обязательные env при старте (dev/build), чтобы не ловить runtime-ошибки.

## Тестирование (минимальный контракт)
Чтобы «ESLint clean» не был единственным барьером качества:

- **E2E**: Playwright (минимум smoke на ключевые страницы/формы).
- **Требование к новым фичам**: хотя бы 1–2 e2e-сценария на критичный happy-path.
- **Структура**: тесты рядом в `__tests__`/`*.spec.ts` или отдельной папкой `tests/` (зафиксировать один вариант и держать его).

## i18n
Если используем i18next:

- Инициализация — в одном месте (например `app/providers` или `shared/i18n`), без дублирования.
- Ключи/неймспейсы — согласованный нейминг, не хардкодим текст в компонентах без необходимости.
  
## Нормы «что хранить в репозитории»
- Вендорные библиотеки (если вынужденно лежат в `src/assets/lib/*`) считаем third-party: не правим без крайней необходимости, по возможности заменяем npm-зависимостью.
- Сгенерированные артефакты (`out/`, сборка) в репозиторий не коммитим.

## Качество
- ESLint + Prettier обязательны, конфиг проекта считается источником истины (В ПРОЦЕССЕ ДОРАБОТКИ)
- Логика форматирования/валидации (поля, будущие расчеты и привидение чисел к определенному формату, как на стоимости) выносится в чистые функции, не дублируется по компонентам

## Верстка и семантика
- Использовать семантические HTML-теги: 
main, header, footer, nav, section, article, aside, form, fieldset, legend, а не голые div`/`span
- Соблюдать иерархию заголовков:
  - один h1 на страницу/основной экран
  - h2–h6 - строго вложенная структура, без прыжков (не начинать сразу с h3 и т.п.)
- Кнопки и ссылки:
  - действия -  button (с типом type="button" или type="submit" по контексту)
  - переходы -  a`/`Link с корректным href, без подмены button
- Формы:
  - у каждого input/textarea/select должен быть связанный label (через htmlFor`/`id или обёрткой)
  - корректные type (`email`, tel, number, url и т.д.), минимальная клиентская валидация
- Изображения:
  - обязательный смысловой alt (кроме чисто декоративных, где допускается `alt=""`)
  - использовать figure/figcaption, если есть подписи или важный контент
- Списки:
  - использовать ul/ol и li для перечислений, а не псевдосписки на div
- Доступность:
  - не использовать div`/`span вместо интерактивных элементов
  - по необходимости применять aria-* атрибуты, но не дублировать существующую семантику
  - следить за фокусируемостью: интерактивные элементы должны быть доступны с клавиатуры

Периодически обязательно сверять верстку на валидность и прогонять страницы через PageSpeed, регулярность можно разбить, например, на проценты готовности страницы - на 20, на 40, на 60 и т.д. Как будет удобнее и лучше для тебя

## Стили (Tailwind + SCSS modules)
Зона ответственности tailwind - layout (grid, flex, spacings и тд.), 
- Tailwind: быстрый layout/spacing/типографика/простые состояния (`hover:`, `focus:`). Не дублируем это в SCSS, если хватает utility
- SCSS module создаём, когда компоненту нужны собственные состояния/анимации/специфичные селекторы (например, `[data-state]`), переиспользуемые группы стилей или когда utility-классов становится слишком много для читаемости

- Расположение: файл Component.module.scss рядом с компонентом. Для частей в parts/ - свой module рядом с частью. Общие токены/глобальные стили - только в shared/styles (и синхронизируются с `tailwind.config`)

Подробнее: 
Tailwind - всё, что относится к:
- flex, grid, gap, p-, m-, w-, h-, justify-, items-, place-, col-span, order, т.п.
- базовая типографика: text-sm, text-lg
- простые состояния: hover:, focus:, disabled:, active: без сложной логики
- простые декоративные вещи: rounded-lg, border, shadow, bg-slate-100

SCSS module - всё, что:
- требует сложных селекторов: [data-state="open"], [aria-selected="true"], &:has(...)
- вложенные состояния, комплексный ховер, завязки на вложенных DOM-элементах
- анимации, keyframes, сложные transitions
- комбинированные состояния: &:hover:active, &[data-variant="danger"]:disabled
- специфичная визуальная логика, которая повторяется внутри проекта (но не удобна в Tailwind: много conditionals, псевдо-элементы ::before/::after, нестандартные эффекты)

## UI/React-уровень
- Только функциональные компоненты и хуки, без классовых компонентов
- Компоненты - "тонкие", бизнес-логика по возможности вынесена в хуки
- Пропсы иммутабельны, компоненты чистые относительно входных данных 

## Импорт, структура и нейминг
- Чёткая структура импортов:
  - сначала внешние библиотеки
  - затем алиасы проекта (`app`, entities, features, widgets, `shared`)
  - затем относительные пути
- Не использовать магические строки/числа выносить в константы с говорящими именами
- Имена файлов и компонентов осмысленные и согласованные (PascalCase для компонентов, camelCase для функций/переменных, UPPER_SNAKE_CASE для констант)

И самое главное правило, если что-то переиспользуется больше двух раз - значит выносим в переменную или компонент