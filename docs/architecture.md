## Цели
- Писать на TypeScript с strict: true
- Следовать принципам SOLID
- Архитектура: feature-sliced (или layer-based) + чистые зависимости
- 100% ESLint clean, форматирование Prettier
- Не допускать файлы больше 700–800 строк, при необходимости обоснованно выносить в отдельные компоненты/модули
- Код читабельный и единообразный: именование, структура файлов, порядок экспортов

SOLID - как основа при проектировании интерфейсов (не жесткое требование в тонкостях)
- S (SRP): каждый модуль делает одно дело, ничего не смешивать
- O (OCP): расширяем через новые реализации/композицию, а не через правки существующих модулей
- L (LSP): не ломаем контракт при наследовании/реализациях интерфейсов
- I (ISP): мелкие интерфейсы без "божественных" типов
- D (DIP): зависимости через абстракции (интерфейсы/фасады), внедрение - в композиционном корне
- Нарушаем SOLID осознанно, если это упрощает код и не ломает архитектурные границы слоёв

## Границы слоёв
- app/ - композиция, DI-контейнер, маршрутизация, wiring слоёв
- entities/ - базовые доменные модели и логика вокруг них
- features/ - законченные пользовательские возможности на базе entities
- widgets/ - сложные композиции UI из features/entities
- shared/ - утилиты, дизайн-система, базовые типы без бизнес или сложной функциональной (визуальной) логики

Правило зависимостей (не увлекаться по первым двум пунктам, если что - я поправлю, главное, в голове держать основы fsd)
- Запрещено импортировать "вверх" (из более низкого слоя в более высокий)
- Запрещено пересекать срезы feature-sliced напрямую, обходя публичные API (использовать публичные entry-пойнты слоёв)
- Переиспользование через публичные модули (`index.ts`), без "глубоких" относительных импортов в чужие внутренности
- На старте фичи допускается более «толстый» срез (например, часть логики прямо в feature/widget); по мере роста - декомпозировать в entities/shared

## Качество
- ESLint + Prettier обязательны, конфиг проекта считается источником истины (В ПРОЦЕССЕ ДОРАБОТКИ)
- Логика форматирования/валидации (поля, будущие расчеты и привидение чисел к определенному формату, как на стоимости) выносится в чистые функции, не дублируется по компонентам

## Верстка и семантика
- Использовать семантические HTML-теги: 
main, header, footer, nav, section, article, aside, form, fieldset, legend, а не голые div`/`span
- Соблюдать иерархию заголовков:
  - один h1 на страницу/основной экран
  - h2–h6 - строго вложенная структура, без прыжков (не начинать сразу с h3 и т.п.)
- Кнопки и ссылки:
  - действия -  button (с типом type="button" или type="submit" по контексту)
  - переходы -  a`/`Link с корректным href, без подмены button
- Формы:
  - у каждого input/textarea/select должен быть связанный label (через htmlFor`/`id или обёрткой)
  - корректные type (`email`, tel, number, url и т.д.), минимальная клиентская валидация
- Изображения:
  - обязательный смысловой alt (кроме чисто декоративных, где допускается `alt=""`)
  - использовать figure/figcaption, если есть подписи или важный контент
- Списки:
  - использовать ul/ol и li для перечислений, а не псевдосписки на div
- Доступность:
  - не использовать div`/`span вместо интерактивных элементов
  - по необходимости применять aria-* атрибуты, но не дублировать существующую семантику
  - следить за фокусируемостью: интерактивные элементы должны быть доступны с клавиатуры

Периодически обязательно сверять верстку на валидность и прогонять страницы через PageSpeed, регулярность можно разбить, например, на проценты готовности страницы - на 20, на 40, на 60 и т.д. Как будет удобнее и лучше для тебя

## Стили (Tailwind + SCSS modules)
Зона ответственности tailwind - layout (grid, flex, spacings и тд.), 
- Tailwind: быстрый layout/spacing/типографика/простые состояния (`hover:`, `focus:`). Не дублируем это в SCSS, если хватает utility
- SCSS module создаём, когда компоненту нужны собственные состояния/анимации/специфичные селекторы (например, `[data-state]`), переиспользуемые группы стилей или когда utility-классов становится слишком много для читаемости

- Расположение: файл Component.module.scss рядом с компонентом. Для частей в parts/ - свой module рядом с частью. Общие токены/глобальные стили - только в shared/styles (и синхронизируются с `tailwind.config`)

Подробнее: 
Tailwind - всё, что относится к:
- flex, grid, gap, p-, m-, w-, h-, justify-, items-, place-, col-span, order, т.п.
- базовая типографика: text-sm, text-lg
- простые состояния: hover:, focus:, disabled:, active: без сложной логики
- простые декоративные вещи: rounded-lg, border, shadow, bg-slate-100

SCSS module - всё, что:
- требует сложных селекторов: [data-state="open"], [aria-selected="true"], &:has(...)
- вложенные состояния, комплексный ховер, завязки на вложенных DOM-элементах
- анимации, keyframes, сложные transitions
- комбинированные состояния: &:hover:active, &[data-variant="danger"]:disabled
- специфичная визуальная логика, которая повторяется внутри проекта (но не удобна в Tailwind: много conditionals, псевдо-элементы ::before/::after, нестандартные эффекты)

## UI/React-уровень
- Только функциональные компоненты и хуки, без классовых компонентов
- Компоненты - "тонкие", бизнес-логика по возможности вынесена в хуки
- Пропсы иммутабельны, компоненты чистые относительно входных данных 

## Импорт, структура и нейминг
- Чёткая структура импортов:
  - сначала внешние библиотеки
  - затем алиасы проекта (`app`, entities, features, widgets, `shared`)
  - затем относительные пути
- Не использовать магические строки/числа выносить в константы с говорящими именами
- Имена файлов и компонентов осмысленные и согласованные (PascalCase для компонентов, camelCase для функций/переменных, UPPER_SNAKE_CASE для констант)

И самое главное правило, если что-то переиспользуется больше двух раз - значит выносим в переменную или компонент